import Vue from 'vue'

let constant = {
  INITIAL_SCALE: 'scale(0.0001, 0.0001)',
  INITIAL_SIZE: '1px',
  INITIAL_OPACITY: '0.4',
  FINAL_OPACITY: '0',
  FINAL_SCALE: ''
}

let cssClasses = {
  RIPPLE_CENTER: 'mdl-ripple--center',
  RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
  RIPPLE: 'mdl-ripple',
  IS_ANIMATING: 'is-animating',
  IS_VISIBLE: 'is-visible'
}

let downHandler_ = function (event) {
  this.rippleElement_ = this.el.querySelector('.' + cssClasses.RIPPLE)
  console.log('downHandler_', this.rippleElement_)
  this.rippleElement_.style.color = 'red'
  // return
  if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
    let rect = this.el.getBoundingClientRect()
    this.boundHeight = rect.height
    this.boundWidth = rect.width
    this.rippleSize_ = Math.sqrt(rect.width * rect.width +
        rect.height * rect.height) * 2 + 2
    this.rippleElement_.style.width = this.rippleSize_ + 'px'
    this.rippleElement_.style.height = this.rippleSize_ + 'px'
    this.rippleElement_.style.color = 'red'
  }

  this.rippleElement_.classList.add(cssClasses.IS_VISIBLE)

  if (event.type === 'mousedown' && this.ignoringMouseDown_) {
    this.ignoringMouseDown_ = false
  } else {
    if (event.type === 'touchstart') {
      this.ignoringMouseDown_ = true
    }
    let frameCount = this.getFrameCount()
    if (frameCount > 0) {
      return
    }
    this.setFrameCount(1)
    let bound = event.currentTarget.getBoundingClientRect()
    let x
    let y
    // Check if we are handling a keyboard click.
    if (event.clientX === 0 && event.clientY === 0) {
      x = Math.round(bound.width / 2)
      y = Math.round(bound.height / 2)
    } else {
      let clientX = event.clientX ? event.clientX : event.touches[0].clientX
      let clientY = event.clientY ? event.clientY : event.touches[0].clientY
      x = Math.round(clientX - bound.left)
      y = Math.round(clientY - bound.top)
    }
    this.setRippleXY(x, y)
    this.setRippleStyles(true)
    window.requestAnimationFrame(this.animFrameHandler.bind(this))
  }
}

/**
 * Handle mouse / finger up on element.
 *
 * @param {Event} event The event that fired.
 * @private
 */
let upHandler_ = function (event) {
  console.log('upHandler_')
  // Don't fire for the artificial "mouseup" generated by a double-click.
  if (event && event.detail !== 2) {
    // Allow a repaint to occur before removing this class, so the animation
    // shows for tap events, which seem to trigger a mouseup too soon after
    // mousedown.
    window.setTimeout(function () {
      this.rippleElement_.classList.remove(cssClasses.IS_VISIBLE)
    }.bind(this), 0)
  }
}

Vue.directive('md-ripple', {
  bind () {
    let recentering = this.el.classList.contains(cssClasses.RIPPLE_CENTER)
    if (!this.el.classList.contains(cssClasses.RIPPLE_EFFECT_IGNORE_EVENTS)) {
      this.rippleElement_ = this.el.querySelector('.' + cssClasses.RIPPLE)
      this.frameCount_ = 0
      this.rippleSize_ = 0
      this.x_ = 0
      this.y_ = 0

      this.ignoringMouseDown_ = false

      this.boundDownHandler = downHandler_.bind(this)
      this.el.addEventListener('mousedown', this.boundDownHandler)
      this.el.addEventListener('touchstart', this.boundDownHandler)

      this.boundUpHandler = upHandler_.bind(this)
      this.el.addEventListener('mouseup', this.boundUpHandler)
      this.el.addEventListener('mouseleave', this.boundUpHandler)
      this.el.addEventListener('touchend', this.boundUpHandler)
      this.el.addEventListener('blur', this.boundUpHandler)

      /**
       * Getter for frameCount_.
       * @return {number} the frame count.
       */
      this.getFrameCount = function () {
        return this.frameCount_
      }

      /**
       * Setter for frameCount_.
       * @param {number} fC the frame count.
       */
      this.setFrameCount = function (fC) {
        this.frameCount_ = fC
      }

      /**
       * Getter for rippleElement_.
       * @return {Element} the ripple element.
       */
      this.getRippleElement = function () {
        return this.rippleElement_
      }

      /**
       * Sets the ripple X and Y coordinates.
       * @param  {number} newX the new X coordinate
       * @param  {number} newY the new Y coordinate
       */
      this.setRippleXY = function (newX, newY) {
        this.x_ = newX
        this.y_ = newY
      }

      /**
       * Sets the ripple styles.
       * @param  {boolean} start whether or not this is the start frame.
       */
      this.setRippleStyles = function (start) {
        if (this.rippleElement_ !== null) {
          let transformString
          let scale
          let offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)'

          if (start) {
            scale = constant.INITIAL_SCALE
          } else {
            scale = constant.FINAL_SCALE
            if (recentering) {
              offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
                this.boundHeight / 2 + 'px)'
            }
          }

          transformString = 'translate(-50%, -50%) ' + offset + scale

          this.rippleElement_.style.webkitTransform = transformString
          this.rippleElement_.style.msTransform = transformString
          this.rippleElement_.style.transform = transformString

          if (start) {
            this.rippleElement_.classList.remove(cssClasses.IS_ANIMATING)
          } else {
            this.rippleElement_.classList.add(cssClasses.IS_ANIMATING)
          }
        }
      }

      /**
       * Handles an animation frame.
       */
      this.animFrameHandler = function () {
        if (this.frameCount_-- > 0) {
          window.requestAnimationFrame(this.animFrameHandler.bind(this))
        } else {
          this.setRippleStyles(false)
        }
      }
    }
  },
  update (newVal, oldVal) {

  },
  unbind () {

  }
})
